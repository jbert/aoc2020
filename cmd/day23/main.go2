package main

import (
	"aoc"
	"fmt"
	"strings"
)

func main() {
	a := aoc.New(23)
	a.SetExampleData(`
389125467
`)
	//a.UseExampleData(true)
	lines := a.ReadLines()
	cups := parseLine(lines[0])
	fmt.Printf("cups: %s\n", cups)

	move := 1
	numMoves := 100
	for move <= numMoves {
		fmt.Printf("\nMove %d: cups: %s\n", move, cups)
		cups.Move()
		move++
	}
	fmt.Printf("\nFinal: cups: %s\n", cups)
	fmt.Printf("After1 order: %s\n", cups.Order())
}

type Node struct {
	v    int
	next *Node
}

type Cups struct {
	cups *Node
}

func NewCups(vs []int) *Cups {
	nodes := aoc.Map(func(v int) *Node { return &Node{v: v} }, vs)
	for i := range nodes {
		if i != len(nodes)-1 {
			nodes[i].next = nodes[i+1]
		}
	}
	nodes[len(nodes)-1].next = nodes[0]
	return &Cups{cups: nodes[0]}
}

func parseLine(s string) *Cups {
	nums := aoc.Map(aoc.MustAtoi, strings.Split(s, ""))
	return NewCups(nums)
}

func (c Cups) String() string {
	s := fmt.Sprintf("(%d)", c.cups.v)
	for node := c.cups.next; node != c.cups; node = node.next {
		s += fmt.Sprintf(" %d", node.v)
	}
	return s
}

func (c *Cups) Move() {
	first, last := c.Take(3)

	var pickup []int
	for node := first; node != last.next; node = node.next {
		pickup = append(pickup, node.v)
	}
	fmt.Printf("pickup %v\n", pickup)
	// The crab selects a destination cup: the cup with a label equal to the
	// current cup's label minus one.
	fmt.Printf("destination %d\n", c.cups.v-1)
	dest := c.MoveFind(c.cups.v - 1)
	last.next = dest.next
	dest.next = first

	c.cups = c.cups.next
}

func (c *Cups) Order() string {
	one, _, _ := c.find(1)
	s := ""
	for node := one.next; node != one; node = node.next {
		s += fmt.Sprintf("%d", node.v)
	}
	return s
}

func (c *Cups) MoveFind(label int) *Node {
	//	fmt.Printf("cups %s movefind %d\n", c, label)
	node, lo, hi := c.find(label)
	if node != nil {
		return node
	}
	/*
		If this would select one of the cups
		that was just picked up, the crab will keep subtracting one until it
		finds a cup that wasn't just picked up. If at any point in this process
		the value goes below the lowest value on any cup's label, it wraps
		around to the highest value on any cup's label instead.
	*/
	for label >= lo {
		node, _, _ := c.find(label)
		if node != nil {
			return node
		}
		label--
	}
	node, _, _ = c.find(hi)
	if node == nil {
		panic("wtf")
	}
	return node
}

func (c *Cups) find(label int) (*Node, int, int) {
	if c.cups.v == label {
		return c.cups, 0, 0
	}
	lo := 0
	hi := 0
	for node := c.cups.next; node != c.cups; node = node.next {
		if node.v == label {
			return node, 0, 0
		}
		if lo == 0 || node.v < lo {
			lo = node.v
		}
		if hi == 0 || node.v > hi {
			hi = node.v
		}
	}
	return nil, lo, hi
}

func (c *Cups) Take(howMany int) (*Node, *Node) {
	first := c.cups.next
	last := c.cups
	for ; howMany > 0; howMany-- {
		last = last.next
	}
	c.cups.next = last.next
	last.next = nil
	return first, last
}
