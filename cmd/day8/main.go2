package main

import (
	"aoc"
	"aoc/bitmap"
	"fmt"
	"strconv"
	"strings"
)

func main() {
	a := aoc.New(8)
	a.SetExampleData(`
nop +0
acc +1
jmp +4
acc +3
jmp -3
acc -99
acc +1
jmp -4
acc +6
`)
	//a.UseExampleData(true)

	lines := a.ReadLines()
	insts := aoc.Map(NewInstruction, lines)

	device := NewDevice(insts)
	device.Trace = true
	acc, err := device.RunUntilRepeat()
	if err != nil {
		fmt.Printf("Can't run device: %s\n", err)
		return
	}
	fmt.Printf("RUR: %d\n", acc)
}

type Device struct {
	acc          int
	ip           int
	instructions []Instruction
	seen         *bitmap.Bitmap

	Trace bool
}

func NewDevice(insts []Instruction) *Device {
	return &Device{
		instructions: insts,
		seen:         bitmap.New(len(insts)),
	}
}

func (d *Device) RunUntilRepeat() (int, error) {
	for {
		if seen, _ := d.seen.Get(d.ip); seen {
			fmt.Printf("JB - already seen %d\n", d.ip)
			return d.acc, nil
		}
		inst := d.instructions[d.ip]
		d.seen.Set(d.ip)
		if d.Trace {
			fmt.Printf("%d (%d): %s\n", d.ip, d.acc, inst)
		}
		err := d.step(inst)
		if err != nil {
			return 0, fmt.Errorf("Error at ip [%d]: %s", d.ip, err)
		}
	}
}

func (d *Device) step(inst Instruction) error {
	switch inst.op {
	case "nop":
		d.ip++
	case "acc":
		d.acc += inst.arg
		d.ip++
	case "jmp":
		d.ip += inst.arg
	default:
		return fmt.Errorf("Unrecognised opcode: %s", inst.op)
	}
	return nil
}

type Instruction struct {
	op  string
	arg int
}

func NewInstruction(s string) Instruction {
	bits := strings.SplitN(s, " ", 2)
	if len(bits) != 2 {
		panic(fmt.Sprintf("Can't split instruction into two parts: [%s]", s))
	}

	arg, err := strconv.Atoi(bits[1])
	if err != nil {
		panic(fmt.Sprintf("Parse arg as int [%s]: %s", bits[1], err))
	}
	return Instruction{
		op:  bits[0],
		arg: arg,
	}
}

func (inst Instruction) String() string {
	return fmt.Sprintf("%s %+d", inst.op, inst.arg)
}
