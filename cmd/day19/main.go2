package main

import (
	"aoc"
	"fmt"
	"strings"
)

func main() {
	a := aoc.New(19)
	/*
			a.SetExampleData(`
		0: 4 1 5
		1: 2 3 | 3 2
		2: 4 4 | 5 5
		3: 4 5 | 5 4
		4: "a"
		5: "b"

		ababbb
		bababa
		abbbab
		aaabbb
		aaaabbb
		`)
	*/
	/*
			a.SetExampleData(`
		42: 9 14 | 10 1
		9: 14 27 | 1 26
		10: 23 14 | 28 1
		1: "a"
		11: 42 31
		5: 1 14 | 15 1
		19: 14 1 | 14 14
		12: 24 14 | 19 1
		16: 15 1 | 14 14
		31: 14 17 | 1 13
		6: 14 14 | 1 14
		2: 1 24 | 14 4
		0: 8 11
		13: 14 3 | 1 12
		15: 1 | 14
		17: 14 2 | 1 7
		23: 25 1 | 22 14
		28: 16 1
		4: 1 1
		20: 14 14 | 1 15
		3: 5 14 | 16 1
		27: 1 6 | 14 18
		14: "b"
		21: 14 1 | 1 14
		25: 1 1 | 1 14
		22: 14 14
		8: 42
		26: 14 22 | 1 20
		18: 15 15
		7: 14 5 | 1 21
		24: 14 1

		abbbbbabbbaaaababbaabbbbabababbbabbbbbbabaaaa
		bbabbbbaabaabba
		babbbbaabbbbbabbbbbbaabaaabaaa
		aaabbbbbbaaaabaababaabababbabaaabbababababaaa
		bbbbbbbaaaabbbbaaabbabaaa
		bbbababbbbaaaaaaaabbababaaababaabab
		ababaaaaaabaaab
		ababaaaaabbbaba
		baabbaaaabbaaaababbaababb
		abbbbabbbbaaaababbbbbbaaaababb
		aaaaabbaabaaaaababaa
		aaaabbaaaabbaaa
		aaaabbaabbaaaaaaabbbabbbaaabbaabaaa
		babaaabbbaaabaababbaabababaaab
		aabbbbbaabbbaaaaaabbbbbababaaaaabbaaabba
		`)
	*/

	a.SetExampleData(`
0: 1 2
1: 10 20 | 10 20 1
2: 20 10
10: "a"
20: "b"

ababba
abba
baba
abb
aba
ba
`)
	a.UseExampleData(true)
	groups := a.ReadLineGroups()
	messages := groups[1]

	/*
		matcher := parseRules(groups[0])
		count := 0
		for _, m := range messages {
			matches := matcher(m)
			fmt.Printf("%s -> %v\n", m, matches)
			if matches {
				count++
			}
		}
		fmt.Printf("%d messages match\n", count)
	*/

	/*
		for i := range groups[0] {
			// 8: 42
			if strings.HasPrefix(groups[0][i], "8:") {
				fmt.Printf("JB - replaced 8\n")
				groups[0][i] = "8: 42 | 42 8"
			}
			// 11: 42 31
			if strings.HasPrefix(groups[0][i], "11:") {
				fmt.Printf("JB - replaced 11\n")
				groups[0][i] = "11: 42 31 | 42 11 31"
			}
		}
	*/
	logOn = true
	matcher := parseRules(groups[0])
	count := 0
	for _, m := range messages {
		matches := matcher(m)
		YN := "N"
		if matches {
			YN = "Y"
		}
		fmt.Printf("%s: %v\n", YN, m)
		if matches {
			count++
		}
	}
	fmt.Printf("%d messages match\n", count)
}

func parseRules(lines []string) func(s string) bool {
	maxRuleIndex := 0
	for _, l := range lines {
		colon := strings.Index(l, ": ")
		if colon < 0 {
			panic("wtf")
		}
		ruleIndex := aoc.MustAtoi(l[:colon])
		if ruleIndex > maxRuleIndex {
			maxRuleIndex = ruleIndex
		}
	}
	rules := make([]Rule, maxRuleIndex+1)

	for _, l := range lines {
		colon := strings.Index(l, ": ")
		if colon < 0 {
			panic("wtf")
		}
		ruleIndex := aoc.MustAtoi(l[:colon])
		//fmt.Printf("RULE: %d [%s]\n", ruleIndex, l)
		if rules[ruleIndex] != nil {
			panic(fmt.Sprintf("Overwriting rule %d", ruleIndex))
		}
		rules[ruleIndex] = parseRule(fmt.Sprintf("RI: %d", ruleIndex), rules, l[colon+2:])
	}
	return func(s string) bool {
		matched := rules[0](s)
		return matched == len(s)
	}
}

func parseRule(name string, rules []Rule, s string) Rule {
	s = strings.TrimLeft(s, " ")
	s = strings.TrimRight(s, " ")

	if s[0] == '"' {
		//fmt.Printf("JB - MMC [%c]\n", s[1])
		return MakeMatchChar(name, s, s[1])
	}
	pipe := strings.Index(s, "|")
	if pipe > 0 {
		first := parseRule(fmt.Sprintf("%s first", name), rules, s[0:pipe])
		second := parseRule(fmt.Sprintf("%s second", name), rules, s[pipe+1:])
		//fmt.Printf("JB - MAL [%s , %s]\n", s[0:pipe], s[pipe+1:])
		return MakeAtLeastOne(name, s, []*Rule{&first, &second})
	}

	bits := strings.Split(s, " ")
	if len(bits) < 1 {
		panic(fmt.Sprintf("Ooops: %s\n", s))
	}
	ruleIndices := aoc.Map(aoc.MustAtoi, bits)
	//fmt.Printf("JB - MS [%v]\n", ruleIndices)
	var sequence []*Rule
	for _, ri := range ruleIndices {
		sequence = append(sequence, &rules[ri])
	}
	return MakeSequence(name, s, sequence)
}

// A rule attempt to match at the beginning of the string
// It returns the number of matched chars, -1 if no match
type Rule func(s string) int

func MakeAtLeastOne(name string, ruleStr string, rules []*Rule) Rule {
	f := func(s string) int {
		InLog(fmt.Sprintf("%s (%s) [%s]: ", name, ruleStr, s))
		for _, r := range rules {
			matched := (*r)(s)
			if matched > 0 {
				OutLog(fmt.Sprintf("Y %d", matched))
				return matched
			}
		}
		OutLog("NO")
		return -1
	}
	return f
}

func MakeSequence(name string, ruleStr string, rules []*Rule) Rule {
	f := func(s string) int {
		InLog(fmt.Sprintf("%s (%s) [%s]: ", name, ruleStr, s))
		totalMatched := 0
		for _, r := range rules {
			matched := (*r)(s[totalMatched:])
			if matched < 0 {
				OutLog("NO")
				return -1
			}
			totalMatched += matched
		}
		OutLog(fmt.Sprintf("Y %d", totalMatched))
		return totalMatched
	}
	return f
}

func MakeMatchChar(name string, ruleStr string, v byte) Rule {
	f := func(s string) int {
		InLog(fmt.Sprintf("%s (%s) [%s]: ", name, ruleStr, s))
		if len(s) == 0 {
			OutLog("NO")
			return -1
		}
		if s[0] == v {
			OutLog("Y 1")
			return 1
		} else {
			OutLog("NO")
			return -1
		}
	}
	return f
}

var logOn bool
var depth int

func InLog(s string) {
	if logOn {
		fmt.Printf("%s%s\n", getIndent(), s)
	}
	depth++
}

func OutLog(s string) {
	strIndent := getIndent()
	depth--
	if logOn {
		fmt.Printf("%s%s\n", strIndent, s)
	}
}

// Is there a printf specifier for this?
func getIndent() string {
	s := ""
	for i := 0; i < depth; i++ {
		s += " "
	}
	return s
}
