package main

import (
	"aoc"
	"fmt"
	"strings"
)

type PrettyByte byte

func (pb PrettyByte) String() string {
	return fmt.Sprintf("%c", pb)
}

func (pb PrettyByte) Copy() PrettyByte { return pb }

const (
	Active = '#'
	InActive = '.'
)

func main() {
	a := aoc.New(17)
	a.SetExampleData(`
.#.
..#
###
`)
	//a.UseExampleData(true)
	lines := a.ReadLines()

	d := NewDim(lines)
	var active int
	for i := 0; i < 6; i++ {
//		fmt.Printf("%s\n\n", d)
		_, active = d.Tick()
	}

	fmt.Printf("%d active cubes\n", active)

//	v := NewVVec[PrettyByte](newPrettyByte)
//	fmt.Printf("%s\n", v)
//	v.Set(0, '#')
//	fmt.Printf("%s\n", v)
//	v.Set(1, '#')
//	fmt.Printf("%s\n", v)
//	v.Set(0, '#')
//	fmt.Printf("%s\n", v)
//	v.Set(-3, '#')
//	fmt.Printf("%s\n", v)
}

func newPrettyByte() PrettyByte { return '.' }
func copyPrettyByte(pb PrettyByte) PrettyByte { return pb }
func newLine() *aoc.VVec[PrettyByte] { return aoc.NewVVec[PrettyByte](newPrettyByte, copyPrettyByte) }
func copyLine(l *aoc.VVec[PrettyByte]) *aoc.VVec[PrettyByte] { return l.Copy() }
func newPlane() *aoc.VVec[*aoc.VVec[PrettyByte]] { return aoc.NewVVec(newLine, copyLine) }
func copyPlane(p *aoc.VVec[*aoc.VVec[PrettyByte]]) *aoc.VVec[*aoc.VVec[PrettyByte]] { return p.Copy() }

type Dim struct {
	cubes *aoc.VVec[*aoc.VVec[*aoc.VVec[PrettyByte]]]
	xlo, xhi int
	ylo, yhi int
	zlo, zhi int
}

func NewDim(lines []string) *Dim {
	d := &Dim{
		cubes: aoc.NewVVec[*aoc.VVec[*aoc.VVec[PrettyByte]]](newPlane, copyPlane),
	}
	for y, l := range lines {
		fmt.Printf("JB line %d: %s\n", y, l)
		for x := range l {
			d.Set(x, y, 0, l[x])
		}
	}
	return d
}

func (d *Dim) note(x, y, z int) {
	if x < d.xlo {
		d.xlo = x
	}
	if y < d.ylo {
		d.ylo = y
	}
	if z < d.zlo {
		d.zlo = z
	}

	if x > d.xhi {
		d.xhi = x
	}
	if y > d.yhi {
		d.yhi = y
	}
	if z > d.zhi {
		d.zhi = z
	}
}

func (d *Dim) Set(x, y, z int, v byte) {
	d.note(x, y, z)
	plane := d.cubes.Get(z)
	line := plane.Get(y)
	line.Set(x, PrettyByte(v))
	plane.Set(y, line)
	d.cubes.Set(z, plane)
}

func (d *Dim) Get(x, y, z int) byte {
	plane := d.cubes.Get(z)
	line := plane.Get(y)
	return byte(line.Get(x))
}

func (d *Dim) GetNeighbours(x, y, z int) []byte {
	var ns []byte
	for dz := -1; dz <= 1; dz++ {
		for dy := -1; dy <= 1; dy++ {
			DX:
			for dx := -1; dx <= 1; dx++ {
				if dx == 0 && dy == 0 && dz == 0 {
					continue DX
				}
				ns = append(ns, d.Get(x+dx,y+dy,z+dz))
			}
		}
	}
	return ns
}

func (d *Dim) Tick() (int, int) {
	numActive := 0
	numChanged := d.VisitWithNeighboursCopy(func (v byte, ns []byte) byte {
		activeNs := aoc.Filter(func(v byte) bool { return v == Active }, ns)
		if v == Active {
			if (len(activeNs) == 2 || len(activeNs) == 3) {
				numActive++
				return Active
			} else {
				return InActive
			}
		} else {
			if len(activeNs) == 3 {
				numActive++
				return Active
			} else {
				return InActive
			}
		}
	})
	return numChanged, numActive
}

func (d *Dim) VisitWithNeighboursCopy(f func(v byte, ns []byte) byte) int {
	changes := 0
	newDim := NewDim([]string{})
	for z := d.zlo-1; z <= d.zhi+1; z++ {
		for y := d.ylo-1; y <= d.yhi+1; y++ {
			for x := d.xlo-1; x <= d.xhi+1; x++ {
				v := d.Get(x,y,z)
				ns := d.GetNeighbours(x,y,z)
				newV := f(v, ns)
				if newV != v {
					changes++
				}
				newDim.Set(x,y,z,newV)
			}
		}
	}
	*d = *newDim
	return changes
}


func (d Dim) String() string {
	lines := []string{
		fmt.Sprintf("x %d - %d y %d - %d z %d - %d", d.xlo, d.xhi, d.ylo, d.yhi, d.zlo, d.zhi),
	}
	for z := d.zlo; z <= d.zhi; z++ {
		lines = append(lines, fmt.Sprintf("z=%d", z))
		for y := d.ylo; y <= d.yhi; y++ {
			l := ""
			for x := d.xlo; x <= d.xhi; x++ {
				l += fmt.Sprintf("%c", d.Get(x, y, z))
			}
			lines = append(lines, l)
		}
		lines = append(lines, "")
	}
	return strings.Join(lines, "\n")
}
