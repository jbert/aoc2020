package main

import (
	"aoc"
	"fmt"
	"strings"
)

func main() {
	a := aoc.New(16)
	a.SetExampleData(`
class: 1-3 or 5-7
row: 6-11 or 33-44
seat: 13-40 or 45-50

your ticket:
7,1,14

nearby tickets:
7,3,47
40,4,50
55,2,20
38,6,12
`)
	//a.UseExampleData(true)

	groups := a.ReadLineGroups()
	fmt.Printf("Groups: %v\n", groups)
	classes := aoc.Map(NewClass, groups[0])
	fmt.Printf("Classes: %v\n", classes)

	nearby := aoc.Map(NewTicket, groups[2][1:])
	fmt.Printf("Nearby: %v\n", nearby)

	var allRules []Rule
	for _, c := range classes {
		allRules = append(allRules, c.rules...)
	}

	errorRate := 0
	for _, t := range nearby {
		invalid, v := t.InvalidValue(allRules)
		if invalid {
			errorRate += v
		}
	}
	fmt.Printf("Error rate: %d\n", errorRate)
	//	my := aoc.Map(NewTicket, groups[1][1:])
}

type Ticket struct {
	values []int
}

func NewTicket(s string) Ticket {
	return Ticket{
		values: aoc.Map(aoc.MustAtoi, strings.Split(s, ",")),
	}
}

func (t Ticket) InvalidValue(rules []Rule) (bool, int) {
VALUE:
	for _, v := range t.values {
		for _, r := range rules {
			if r.Validate(v) {
				continue VALUE
			}
		}
		// Not valid for any rule
		return true, v
	}
	return false, 0
}

type Rule struct {
	lo, hi int
}

func NewRule(s string) Rule {
	r := Rule{}
	bits := strings.Split(s, "-")
	r.lo = aoc.MustAtoi(bits[0])
	r.hi = aoc.MustAtoi(bits[1])
	return r
}

func (r Rule) Validate(v int) bool {
	return r.lo <= v && v <= r.hi
}

type Class struct {
	name  string
	rules []Rule
}

func (c Class) String() string {
	return fmt.Sprintf("%s: %v", c.name, c.rules)
}

func NewClass(s string) Class {
	c := Class{}

	colonIndex := strings.Index(s, ": ")
	if colonIndex < 0 {
		panic(fmt.Sprintf("Can't find colon: %s", s))
	}
	c.name = s[:colonIndex]

	rules := s[colonIndex+2:]
	bits := strings.Split(rules, " or ")
	c.rules = []Rule{
		NewRule(bits[0]),
		NewRule(bits[1]),
	}
	return c
}
