package aoc

import (
	"io/ioutil"
	"bytes"
	"fmt"
	"io"
	"bufio"
	"strconv"
	"strings"
	"sort"
)

type AOC struct {
	day int
	exampleData []byte
	useExampleData bool
}

func New(day int) *AOC {
	return &AOC{day: day}
}

func (aoc *AOC) Name() string {
	return fmt.Sprintf("day%d", aoc.day)
}


func (aoc *AOC) SetExampleData(exampleData string) {
	exampleData = strings.TrimLeft(exampleData, "\n")
	aoc.exampleData = []byte(exampleData)
}

func (aoc *AOC) UseExampleData(doit bool) {
	aoc.useExampleData = doit
}

func (aoc *AOC) ReadInts() []int {
	lines := aoc.ReadLines()
	nums := []int{}
	for _, l := range lines {
		num, err := strconv.Atoi(l)
		if err != nil {
			panic(fmt.Sprintf("Can't parse line as number: [%s]: %s", l, err))
		}
		nums = append(nums, num)
	}
	return nums
}

func (aoc *AOC) ReadLineGroups() [][]string {
	lines := aoc.ReadLines()
	var groups [][]string
	var group []string
	for _, l := range lines {
		if l == "" {
			groups = append(groups, group)
			group = []string{}
		} else {
			group = append(group, l)
		}
	}
	if len(group) > 0 {
		groups = append(groups, group)
	}
	return groups
}

func (aoc *AOC) getData() []byte {
	if aoc.useExampleData {
		return aoc.exampleData
	}

	inputPath := fmt.Sprintf("/home/john/dev/jbert/aoc2020/input/%s.txt", aoc.Name())
	buf, err := ioutil.ReadFile(inputPath)
	if err != nil {
		panic(fmt.Sprintf("Can't read input file [%s]: %s", inputPath, err))
	}
	return buf
}

func (aoc *AOC) ReadLines() []string {
	s := aoc.getData()
	r := bytes.NewReader(s)
	b := bufio.NewReader(r)
	lines := []string{}
	for {
		line, err := b.ReadString('\n')
		if line != "" {
			line = line[:len(line)-1]	// Trim newline
			lines = append(lines, line)
		}
		if err != nil {
			if err != io.EOF {
				panic(fmt.Sprintf("Error reading input data: %s", err))
			}
			break
		}
	}
	return lines
}

type Pair[T, U] struct {
	First T
	Second U
}

func (p Pair[T, U]) String() string {
	return fmt.Sprintf("[%v,%v]", p.First, p.Second)
}

func Zip[T, U](ts []T, us []U) []Pair[T,U] {
	if len(ts) != len(us) {
		panic("Do something more clever here")
	}
	var pairs []Pair[T,U]
	for i := range ts {
		pairs = append(pairs, Pair[T, U]{ts[i], us[i]})
	}
	return pairs
}

func Filter[T](f func(T) bool, ts []T) []T {
	var filtered []T
	for _, t := range ts {
		if f(t) {
			filtered = append(filtered, t)
		}
	}
	return filtered
}

func Sort[T Ordered](tsArg []T) []T {
	ts := make([]T, len(tsArg))
	n := copy(ts, tsArg)
	if n != len(tsArg) {
		panic(fmt.Sprintf("LOGIC ERROR - can't copy slice %d != %d", n, len(tsArg)))
	}
	sort.Slice(ts, func(i, j int) bool {
		return ts[i] < ts[j]
	})
	return ts
}

func UniqC[T comparable](ts []T) []int {
	if len(ts) == 0 {
		return []int{}
	}
	var counts []int
	current := ts[0]
	count := 1
	for _, t := range ts[1:] {
		if t == current {
			count++
		} else {
			counts = append(counts, count)
			count = 1
			current = t
		}
	}
	counts = append(counts, count)
	return counts
}

func IntsTo(n int) []int {
	var is []int
	for i := 0; i <= n; i++ {
		is = append(is, i)
	}
	return is
}

func Foldr[T, U](f func(U, T) U, accum U, ts []T) U {
	for _, t := range ts {
		accum = f(accum, t)
	}
	return accum
}

func Map[T, U](f func(T) U, ts []T) []U {
	us := []U{}
	for _, t := range ts {
		u := f(t)
		us = append(us, u)
	}
	return us
}

func Max[T Ordered](l []T) T {
	max := l[0]
	for _, v := range l[1:] {
		if v > max {
			max = v
		}
	}
	return max
}

func BinarySearch[T any](l []T, cmp func(i int) int) (int, bool) {
	if len(l) < 1 {
		return 0, false
	}
	pivot := len(l) / 2
	comparison := cmp(pivot)
	if comparison == 0 {
		return pivot, true
	}
	if len(l) < 2 {
		return 0, false
	}

	if comparison < 0 {
		return BinarySearch(l[:pivot], cmp)
	} else {
		i, ok := BinarySearch(l[pivot:], func(i int) int {
			return cmp(i+pivot)
		})
		return i + pivot, ok
	}
}


// ----
// Copied from : go/src/cmd/go2go/testdata/go2path/src/constraints/constraints.go2


// Ordered permits any ordered type: any type that supports
// the operations <, <=, >=, >, as well as == and !=.
type Ordered interface {
	type int, int8, int16, int32, int64,
	uint, uint8, uint16, uint32, uint64, uintptr,
	float32, float64,
	string
}

// Integer permits any integer type.
type Integer interface {
	type int, int8, int16, int32, int64,
	uint, uint8, uint16, uint32, uint64, uintptr
}

// Signed permits any signed integer type.
type Signed interface {
	type int, int8, int16, int32, int64
}

// Unsigned permits any unsigned integer type.
type Unsigned interface {
	type uint, uint8, uint16, uint32, uint64, uintptr
}

type Numeric interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64,
		complex64, complex128
}
